package generate

import (
	"fmt"
	"strings"

	"ctxsave/internal/compress"
	"ctxsave/internal/store"
)

type PromptGenerator struct {
	store      *store.Store
	summarizer *compress.Summarizer
	project    string
}

func NewPromptGenerator(st *store.Store, project string) *PromptGenerator {
	return &PromptGenerator{
		store:      st,
		summarizer: compress.NewSummarizer(),
		project:    project,
	}
}

type GenerateOptions struct {
	ModelKey string
	Budget   int
	Sessions int // how many recent sessions to include, 0 = all
}

func (g *PromptGenerator) Generate(opts GenerateOptions) (string, error) {
	model, ok := GetModel(opts.ModelKey)
	if !ok {
		return "", fmt.Errorf("unknown model %q — run 'ctxsave models' to list", opts.ModelKey)
	}

	budget := opts.Budget
	if budget <= 0 {
		budget = defaultBudget(model)
	}
	if budget > model.ContextLimit/2 {
		budget = model.ContextLimit / 2
	}

	entries, err := g.store.GetAllEntries(500)
	if err != nil {
		return "", fmt.Errorf("fetch entries: %w", err)
	}

	if len(entries) == 0 {
		return "", fmt.Errorf("no context captured yet — run 'ctxsave capture' first")
	}

	summaries := g.summarizer.Summarize(entries)
	level, content := g.summarizer.BestFit(summaries, budget, model.Family)

	prompt := g.buildPrompt(model, content, level, len(entries), budget)
	return prompt, nil
}

func (g *PromptGenerator) buildPrompt(model ModelProfile, content, level string, entryCount, budget int) string {
	var sb strings.Builder

	sb.WriteString("# Project Context Briefing\n\n")
	sb.WriteString(fmt.Sprintf("**Project:** %s\n", g.project))
	sb.WriteString(fmt.Sprintf("**Target Model:** %s\n", model.Name))
	sb.WriteString(fmt.Sprintf("**Compression Level:** %s (%d entries summarized)\n", level, entryCount))
	sb.WriteString(fmt.Sprintf("**Token Budget:** ~%d tokens\n\n", budget))
	sb.WriteString("---\n\n")
	sb.WriteString(content)
	sb.WriteString("\n---\n\n")
	sb.WriteString("*This briefing was generated by ctxsave. Continue the work described above.*\n")

	return sb.String()
}

func defaultBudget(model ModelProfile) int {
	limit := model.ContextLimit
	switch {
	case limit >= 500000:
		return 16000
	case limit >= 100000:
		return 8000
	default:
		return 4000
	}
}
